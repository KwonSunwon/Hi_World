----------------------------------------------------------------------------
Wed Nov 13 13:09:46 2019
----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// 2019. 11. 13  수	   C++월56수34			 (11주 2일)
//
// 클래스 간의 관계 - 상속
//	1. 기존 코드를 재사요한다
//	2. 다형성을 구현한다
//-----------------------------------------------------------------------------

#include <iostream>
#include <string>
#include "save.h"

using namespace std;

// 멤버 함수에 virtual을 붙이게 되면
// 클래스 객체가 생성될 때 포인터 한개(4byte)가 멤버 변수에 추가된다.
//
// 이 포인터의 이름은 vptr( virtual pointer ) 인데
// vptr은 vtb( vitual table )을 가리킨다

class Animal {
	int a;
public:
	virtual void speak ( ) const {		// 이 함수는 진짜가 아니야
	cout << "동물들은 speak 할 수 있어" << endl;
	}
};

class Dog : public Animal {
	int d;
public:
	virtual void speak ( )const override {		// virtual 안써도 가능	// const -> 한정자의 한 종류 : 자격을 한정해줌 (qualifier?)
		cout << "멍멍" << endl;
	}
};

class Cat : public Animal {
	int c;
	int cc;
public:
	virtual void speak ( )const override {
		cout << "애옹" << endl;
	}
};

// 동물 호텔을 운영한다.
// 동물을 100마리까지 수용할 수 있다.
// 개와 고양이를 손님으로 받을 수 있다.

// 투숙중인 손님 전체 명단을 출력할 수 있어야 한다.

int main()
{
	// 100 마리가 들어갈 공간을 어떻게 만들까?
	// Animal a[100] - 크기가 부족하다

	Animal* animals [100];

	Dog d;
	animals[0] = &d;	// animals[0] = new Dog;
	animals[1] = new Cat;
	animals[2] = new Cat;

	for(int i = 0 ; i < 3 ; ++i )
		animals[i]->speak();

	delete animals[1];
	delete animals[2];

	save( "소스.cpp" );
}

여기서 delete animals[0] 하면 오류남 왜지?
